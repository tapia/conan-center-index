import org.yaml.snakeyaml.Yaml

RAISE_HOOKS = true

def envInside(Map ctxt, Closure closure) {
    String venvDirectory = isUnix() ? "${pwd()}/conanenv" : "${pwd()}\\conanenv"
    String binPath = isUnix() ? "$venvDirectory/bin/" : "$venvDirectory\\Scripts\\"
    String conanHome = isUnix() ? "${pwd()}/.conan" : "${pwd()}\\.conan"
    String hookErrorLevel = RAISE_HOOKS ? '40' : '50'
    withEnv(["PATH+EXTRA=${binPath}", "CONAN_USER_HOME=${conanHome}", "CONAN_USER_HOME_SHORT=${conanHome}", "CONAN_HOOK_ERROR_LEVEL=${hookErrorLevel}"]) {
        // This doesn't work if running docker.inside (https://issues.jenkins.io/browse/JENKINS-49076)
        closure()
    }
}

def envCreate(Map ctxt) {
    String venvDirectory = isUnix() ? "${pwd()}/conanenv" : "${pwd()}\\conanenv"
    String binPath = isUnix() ? "$venvDirectory/bin/" : "$venvDirectory\\Scripts\\"
    ctxt.shFunction("${ctxt.python_host} --version")
    if (ctxt.isInsideDocker) {
        // Alternate implementation because of https://issues.jenkins.io/browse/JENKINS-49076
        ctxt.shFunction('pip install -e git+https://github.com/conan-io/conan.git@develop#egg=conan')
    }
    else {
        ctxt.shFunction("${ctxt.python_host} -m venv $venvDirectory")
        ctxt.shFunction("${binPath}python -m pip install -U pip")
        ctxt.shFunction("${binPath}python -m pip install -e git+https://github.com/conan-io/conan.git@develop#egg=conan")
    }
}

def createReference(Map ctxt, List recipesToBuild) {
    try {
        stage('Configure environment') {
            envCreate(ctxt)
            envInside(ctxt) {
                ctxt.shFunction('echo \$PATH')
                ctxt.shFunction('conan --version')
                ctxt.shFunction('conan config init --force')
            }
        }

        for (recipe in recipesToBuild) {
            stage("Build ${recipe.reference}") {
                echo "${recipe.reference}: ${recipe.folder}"
                ctxt.shFunction("conan info ${recipe.folder} ${recipe.reference}@ --profile=default")
            }
        }
    }
    finally {
        cleanWs(cleanWhenAborted: true, cleanWhenFailure: true, cleanWhenNotBuilt: true,
            cleanWhenSuccess: true, cleanWhenUnstable: true, disableDeferredWipeout: true, deleteDirs: true,
            notFailBuild: true)
    }
}

node('Linux') {
    List<String> recipes = []
    stage('Compute changes') {
        def urc = scm.userRemoteConfigs
        urc[0].refspec = "${urc[0].refspec} +refs/heads/master:refs/remotes/origin/master"
        checkout([
            $class: 'GitSCM',
            branches: scm.branches,
            doGenerateSubmoduleConfigurations: scm.doGenerateSubmoduleConfigurations,
            extensions: scm.extensions,
            userRemoteConfigs: urc
        ])

        def output = sh(script: 'git diff --name-only origin/master --diff-filter=AMR', returnStdout: true)
        for (line in output.split('\n')) {
            def matcher = (line =~ /^recipes\/([^\/]+)\//)
            if (matcher) {
                recipes.add(matcher[0][1] as String)
            }
        }
        recipes.unique(true, { lhs, rhs -> lhs <=> rhs })
    }

    List toBuild = []
    stage('Parse config.yml to get versions') {
        for (recipe in recipes) {
            String content = readFile("recipes/${recipe}/config.yml")
            Yaml parser = new Yaml()
            Map data = parser.load(content)
            def versions = data.get('versions')
            for (int i = 0; i < versions.size(); i++) {
                def version = versions.keySet()[i]
                Map<String, String> props = versions[version]
                toBuild.add([
                    folder: "recipes/${recipe}/${props.folder}/conanfile.py",
                    reference: "${recipe}/${version}"
                ])
            }
        }
        echo "Recipes to build:\n - ${ toBuild.collect({ "$it.reference: $it.folder" }).join('\n - ')}"
    }

    stage('Parallel on platforms') {
        parallel(
            linux: {
                docker.image('conanio/gcc10').inside {
                    createReference([python_host: 'python3', shFunction: { data -> sh(data) }, isInsideDocker: true], toBuild)
                }
            },
            macos: {
                node('Macos') {
                    createReference([python_host: 'python3', shFunction: { data -> sh(data) }, isInsideDocker: false], toBuild)
                }
            },
            windows: {
                node('Windows') {
                    createReference([python_host: 'C:\\Python39\\python.exe', shFunction: { data -> bat(data) }, isInsideDocker: false], toBuild)
                }
            }
        )
    }
}
